# Q&A Chapter 13 拷贝控制

1. ### 拷贝构造函数的第一个参数必须是什么类型？为什么？

   + 必须是引用类型，否则会无限递归调用。

2. ### 拷贝构造函数应该被声明为explicit的么？为什么？

   + 不可以，拷贝构造函数很多情况下是需要被隐式调用的，比如函数传参的时候。如果声明为explicit那么就不能隐式地拷贝了。

3. ### 如果我们定义了其他构造函数，编译器还会合成一个拷贝构造函数么？

   + 会的，与默认构造函数不同，编译器还是会合成一个拷贝构造函数。

4. ### 合成拷贝构造函数会拷贝数组类型的成员么？

   + 会的，虽然使用数组类型时不能复制，但是合成拷贝构造函数会逐元素拷贝数组类型的成员。

5. ### 直接初始化和拷贝初始化的区别？

   + 直接初始化是调用相应的构造函数，进行初始化。
   + 拷贝初始化是使用拷贝构造函数，进行初始化。

6. ### 容器使用insert和push成员时，容器会对元素进行拷贝初始化么？那使用emplace成员时呢？

   + insert和push是进行了拷贝初始化。
   + emplace是进行直接初始化。

7. ### 有非引用类型的参数的函数，在调用时参数是要进行拷贝初始化的么？

   + 是的。

8. ### 如果没有定义拷贝赋值运算符，编译器会合成一个么？

   + 会的。

9. ### 拷贝赋值运算符的声明形式？

   `Foo& operator=(const Foo&);`

10. ### 赋值运算符的右结合性是指右侧的对象作为参数么？

    + 有疑问

11. ### 赋值运算符返回什么值？

    + 返回一个指向左侧运算对象的引用。

12. ### 析构函数可以重载么？

    + 不可以，析构函数不接受参数。

13. ### 智能指针是什么类型？有析构函数么？

    + 是类类型，有析构函数。

14. ### 自动调用析构函数的情况有哪些？

    + 变量在离开其作用域时被销毁。
    + 当一个对象被销毁时，其成员被销毁。
    + 容器被销毁时，其元素被销毁。
    + 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁。
    + 对于临时对象，当创建它的完整表达式结束时被销毁。

15. ### 合成构造函数一般为空么？

    + 一般情况下为空。

16. ### 析构函数的函数体是在成员被自动销毁的隐式过程之前还是之后执行？

    + 在之前执行。

17. ### 析构函数体直接销毁成员么？

    + 不直接销毁，销毁成员是在函数体后隐式执行的。

18. ### 如果一个类需要一个析构函数，是否说明一定需要一个拷贝构造函数和一个拷贝赋值运算符？为什么？举个例子。

    + 是的，说明需要对其内部的成员需要有特别的处理，不能使用默认处理形式。
    + 比如内部用动态创建内存的指针。如果使用默认形式，会指向同一内存，如果一个销毁了，其他都不能用了。

19. ### 需要拷贝操作的类也需要赋值操作么？它们应该相互需要么？举个例子。

    + 是的，应该成对出现。比如要给类中的每一个对象一个特有的id，拷贝和赋值时都需要处理一下。

20. ### =default用于拷贝构造函数和析构函数是什么意思？

    + 要求编译器生成合成版本。

21. ### 怎样在使用=default时区分隐式内联和非内联？

    + 在声明时使用是隐式内联的。
    + 在定义时使用时非内联的。

22. ### =default只能用于合成的成员函数么？

    + 是的。

23. ### =delete是干什么用的？举个例子。

    + 阻止使用合成的成员函数。
    + 比如说在拷贝构造函数使用=delete，则会屏蔽掉合成的拷贝构造函数。

24. ### =delete是否必须出现在函数第一次声明的时候？

    + 是的。

25. ### =delete只能用于合成的成员函数么？

    + 是的。

26. ### 可否将析构函数指定为=delete的？

    + 不可以。

27. ### 在C++11标准之前是通过什么样的方法来阻止拷贝的？

    + 将拷贝构造函数定义为private访问权限。

28. ### 声明但不定义一个成员函数是合法的么？

    + 是合法的。

29. ### 内存的拷贝，应该小心对象自己给自己赋值的情况，应该使用什么方法来避免内存释放数据丢失？

    + 应该先用中间变量来保存一个副本，之后再删除原来的内存单元，再用中间变量来赋值。

30. ### 对于分配了资源的类，定义swap可能是一种很重要的优化手段么？

    + 是的。

31. ### `std::move`是干什么的？

    + 移动内存到新变量

32. ### 为了避免不必要的拷贝带来的非常高的代价，可以使用对象移动方式？有哪些类可以移动但不能拷贝？

    + IO类
    + unique_ptr

33. ### 右值引用类型是否是为了支持移动操作引入的新的引用类型？

    + 是的

34. ### 使用什么符号获取右值引用？

    + &&

35. ### 右值引用绑定在一个将要销毁的对象上？

    + 是的

36. ### 右值引用的两个特点？

    + 所引用的对象将要被销毁。
    + 该对象没有其他用户。

37. ### 是否意味着右值引用的代码可以自由地接管所引用的对象的资源？

    + 是的。

38. ### rr1是一个右值引用，`int &&rr3 = rr1;`和`int &&rr3 = std::move(rr1);`哪个正确？

    + 第二个是正确的，rr1已经成为了一个。

39. ### 对rr1使用std::move以后还可以使用么？

    + 不可以了，内存资源已经移动给新的右值引用，使用旧的右值引用的的行为是未定义的。

40. ### 应该使用move还是std::move？

    + 还是使用std::move，如果使用了命名空间，容易造成命名冲突。

41. ### 移动构造函数和移动赋值运算符，和拷贝的构造函数和运算符有何不同？

    + 参数是&&

42. ### noexcept是干什么用的？

    + 通知标准库我们的构造函数不抛出任何异常。

43. ### noexcept是在声明和定义中都要指定么？

    + 是的，都需要指定。

44. ### vector保证，如果我们调用push_back时发生异常，vector自身不会发生改变？

    + 是的。

45. ### 我们编写一个移动操作时，是否必须确保移动后源对象必须可析构？

    + 是的。移动时会先把源对象的指针成员置为nullptr，然后再调用析构函数。

46. ### 如果一个类既有移动构造函数，又有拷贝构造函数，会使用哪一个？

    + 会根据类别来判断。如果是非static右值，应该使用移动构造函数。