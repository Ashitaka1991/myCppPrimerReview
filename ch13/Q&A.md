# Q&A Chapter 13 拷贝控制

1. 拷贝构造函数的第一个参数必须是什么类型？为什么？
2. 拷贝构造函数应该被声明为explicit的么？为什么？
3. 如果我们定义了其他构造函数，编译器还会合成一个拷贝构造函数么？
4. 合成拷贝构造函数会拷贝数组类型的成员么？
5. 直接初始化和拷贝初始化的区别？
6. 容器使用insert和push成员时，容器会对元素进行拷贝初始化么？那使用emplace成员时呢？
7. 有非引用类型的参数的函数，在调用时参数是要进行拷贝初始化的么？
8. 如果没有定义拷贝赋值运算符，编译器会合成一个么？
9. 拷贝赋值运算符的声明形式？
10. 赋值运算符的右结合性是指右侧的对象作为参数么？
11. 赋值运算符返回什么值？
12. 析构函数可以重载么？
13. 智能指针是什么类型？有析构函数么？
14. 自动调用析构函数的情况有哪些？
15. 合成构造函数一般为空么？
16. 析构函数的函数体是在成员被自动销毁的隐式过程之前还是之后执行？
17. 析构函数体直接销毁成员么？
18. 如果一个类需要一个析构函数，是否说明一定需要一个拷贝构造函数和一个拷贝赋值运算符？为什么？举个例子。
19. 需要拷贝操作的类也需要赋值操作么？它们应该相互需要么？举个例子。
20. =default用于拷贝构造函数和析构函数是什么意思？
21. 怎样在使用=default时区分隐式内联和非内联？
22. =default只能用于合成的成员函数么？
23. =delete是干什么用的？举个例子。
24. =delete是否必须出现在函数第一次声明的时候？
25. =delete只能用于合成的成员函数么？
26. 可否将析构函数指定为=delete的？
27. 在C++11标准之前是通过什么样的方法来阻止拷贝的？
28. 声明但不定义一个成员函数是合法的么？
29. 内存的拷贝，应该小心对象自己给自己赋值的情况，应该使用什么方法来避免内存释放数据丢失？
30. 对于分配了资源的类，定义swap可能是一种很重要的优化手段么？
31. `std::move`是干什么的？
32. 为了避免不必要的拷贝带来的非常高的代价，可以使用对象移动方式？有哪些类可以移动但不能拷贝？
33. 右值引用类型是否是为了支持移动操作引入的新的引用类型？
34. 使用什么符号获取右值引用？
35. 右值引用绑定在一个将要销毁的对象上？
36. 右值引用的两个特点？
37. 是否意味着右值引用的代码可以自由地接管所引用的对象的资源？
38. rr1是一个右值引用，`int &&rr3 = rr1;`和`int &&rr3 = std::move(rr1);`哪个正确？
39. 对rr1使用std::move以后还可以使用么？
40. 应该使用move还是std::move？
41. 移动构造函数和移动赋值运算符，和拷贝的构造函数和运算符有何不同？
42. noexcept是干什么用的？
43. noexcept是在声明和定义中都要指定么？
44. vector保证，如果我们调用push_back时发生异常，vector自身不会发生改变？
45. 我们编写一个移动操作时，是否必须确保移后后源对象必须可析构？
46. 如果一个类既有移动构造函数，又有拷贝构造函数，会使用哪一个？