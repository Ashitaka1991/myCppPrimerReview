# 动态内存与智能指针

1. ### 静态内存，栈内存和堆内存分别保存哪些种类的变量？

   + 静态内存保存：局部static变量，类中的static变量，以及定义在任何函数之外的变量。
   + 栈内存保存：函数内的非static变量。
   + 堆内存（内存池）保存：动态分配的内存。

2. ### 两种智能指针分别是什么？

   + shared_ptr
   + unique_ptr

3. ### 默认初始化智能指针中保存的是什么指针？

   + 空指针

4. ### 使用swap交换两个智能指针中的指针。

   + swap(p,q)
   + p.swap(q)

5. ### 使用make_shared怎样创建智能指针？

   ```c++
   shared_ptr<int> p1 = make_shared<int>(42)
   ```

   相当于使用make_shared直接new出了内存区域，这样就不需要自己先申请内存再进行包装了。

6. ### shared_ptr中的unique()和use_count()分别做什么的？

   + unique()判断当前只能指针是否是唯一的。
   + use_count()返回当前被引用的数量。

7. ### 引用计数，何时增加，何时减小？

   + 作为右值赋值时会增加。
   + 某个指针被销毁时，会减小。

8. ### 引用计数为0时会发生什么？

   + 会调用析构函数，释放内存。

9. ### 直接管理内存的方式？

   + `new delete`

10. ### 如果new创建失败，会是什么情况？怎样在失败后返回一个空指针？

    + 会抛出std::bad_alloc异常
    + `int *p2 = new (nothrow) int`

11. ### 怎样将shared_ptr和new结合使用？

    ```c++
    shared_ptr<int> p2(new int(1024));
    ```

12. ### 为何要避免混合使用？

    + 有可能会将一块内存赋给了多个智能指针，那么在一个智能指针引用计数为0时会回收内存，那么其他的智能指针就会出错。

13. ### unique_ptr怎么初始化？

    + 使用new来初始化
    + `unique_ptr<int> p2(new int(42));`

14. ### 怎样动态创建和删除数组？

    + `int *arr = new int[N];`
    + `delete [] arr;`

15. ### allocator类是干什么用的？

    + 可以先分配内存，需要时再执行创建操作。