# Q&A Chapter 10 泛型算法

1. ### 顺序容器只定义了很少的操作，而使用泛型算法的方式，是否体现了高效的复用理念？

   + 是的。以迭代器为媒介，提供不针对特定类型特定容器的算法。如果在每个容器中都定义这样一套算法，相当于冗余了很多相同的功能代码。

2. ### 大多数算法定义在什么头文件中？一些数值泛型算法定义在什么头文件中？

   + algorithm
   + numeric

3. ### 泛型算法怎样做到不依赖于容器？

   + 使用有统一运算形式的（继承自同一个迭代器基类）迭代器。

4. ### 泛型算法会不会直接添加或是删除元素？

   + 不会的。

5. ### 理解算法的最基本的方法就是了解它们是否读取元素、改变元素或是重排元素。

   + 非修正序列算法
   + 修正序列算法
   + 排序算法
   + 数值算法

6. ### 使用accumulate将vector中给所有的string元素连接起来。

   ```c++
   string sum = accumulate(v.cbegin(),v.cend(),string(""))
   ```

7. ### back_inserter的使用

   ```c++
   vector<int> vec;
   auto it = back_inserter(vec);
   fill_n(it,10,0);
   ```

8. ### replace_copy和back_inserter相结合的使用

   ```c++
   replace_copy(ilst.cbegin(),ilst.cend(),
                back_inserter(ivec),0,42);
   ```

9. ### lambda是否是可调用对象？

   + 是的。

10. ### 除了lambda还有哪些可调用对象？

    + 函数
    + 函数指针
    + 重载了函数调用运算符的类。

11. ### 我们是否可以将lambda理解为未命名的内联函数？

    + 可以。

12. ### lambda函数的返回类型怎么指定？

    + 使用尾置返回类型返回。

13. ### 最简lambda函数怎么定义？

    ```c++
    [](int a){
        
    }
    ```

    捕获列表 + 参数列表 + 函数体

14. ### 如果忽略返回类型，是否可以根据函数体中的代码推断出返回类型？

    + 可以的，但是如果是if...else...中有多个返回值，就推断不出来了，此时需要显式指定。

15. ### lambda是否可以有默认参数？

    + 不可以。

16. ### lambda捕获的是什么范围的变量？

    + 是lambda所在函数中的局部变量。所在函数之外的变量是可以直接使用的。

17. ### lambda是否可以直接使用局部static变量和在它所在函数之外声明的名字？

    + 是的。局部的static变量不需要捕获。

18. ### 被捕获的变量的值是在lambda创建时拷贝还是调用时拷贝？

    + 创建时。

19. ### 怎样设置lambda使用引用捕获方式或是值捕获方式？

    + [&]
    + [=]

20. ### 怎样混用捕获方式？

    + [&,a]
    + [=,&b]

21. ### 几种额外的迭代器：插入迭代器，流迭代器，反向迭代器和移动迭代器。